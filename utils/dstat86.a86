	CPU	8086
	ORG	0100h
;;	TITLE DISKSTAT DISK STATISTICS

;;	NAME ('DISKST')

;------------------------------------------------------------------
; Utility to display disc characteristics and file allocation
;
; Copyright 1983 D. Powys-Lybbe
; Author: D. Powys-Lybbe, MML Systems Ltd., London
; Date: 20th June 1983
;
;------------------------------------------------------------------
; Revisions
; =========
;
; 2015-05-08 John Elliott: Started with the published 1.0 source and 
;           altered it until it builds the version distributed by PCW PD, 
;           which I have called 1.1.
;
; 2015-05-09 John Elliott: Converted to 8080 mnemonics (RMAC syntax) using 
;           XZI, and tidied up by hand. Then converted again to 8086 
;           mnemonics (NASM syntax) using XLT86, and tidied up by hand.
;
;
;
;------------------------------------------------------------------

;------------------------------------------------------------------------
;;;	PAGE


;;;	PUBLIC DEF$DSK,DPB,DPH2,DPH3,DPB$PTR,DPH$PTR,VERS,VERS$REL,VERS$OS
;;;	PUBLIC SAVESP
;;;	PUBLIC BADSEL,SELMSG,BADVERS,VERMSG,BIOS,BADBIOS,JMPMSG
;;;	PUBLIC BIOSPB,BIOS$FUNC,BIOS$AREG,BIOS$BCREG,BIOS$DEREG,BIOS$HLREG
;;;	PUBLIC WAITCR,WAITBUFF,WAITLEN,FETCHDP
;;;	PUBLIC CLEARSCRN,CSNMSG,SCREEN1,S1MSG,S1DSK
;;;	PUBLIC OPTION,OPTQUIT,OPTMSG,OPTBUF,OPTLEN,OPTCHR
;;;	PUBLIC MAKEHEX,WRDHEX,DBLHEX,BYTHEX,NBLHEX,TESTHEX,NEXTHEX
;;;	PUBLIC  HEXCHR,HEXTXT
;;;	PUBLIC MAKEDEC,DEC2,ERRDEC,GIGDEC,MEGDEC,WRDDEC,BYTDEC,TXTDEC,ZROBCD
;;;	PUBLIC TOBCD,BCD,TESTDEC,NEXTDEC,DECCHR,DECTXT
;;;	PUBLIC MAKEMAX,MAKEM1,MAKEM2,MAKEM3,MAKEM4,MAKEM5,MAKEM6,MAKEM8
;;;	PUBLIC MAKEM7,MAKEM9,MAKE01,MAKE02,MAKE03,MAKE04,MAKEM0
;;;	PUBLIC MAKEDIR,DIRDB,DBSIZE,MAKED0,MAKED1,MAKED2,MAKED3,MAKED4
;;;	PUBLIC MAKEDAT,MAKED5,MAKED6
;;;	PUBLIC MAKETOT,MAKED7,MAKED8
;;;	PUBLIC MMEGX8,MMEGX4,MMEGX2,MGIGX8,MGIGX4,MGIGX2,MGIGX128
;;;	PUBLIC SHOWBLK,POSN,SDBMSG,SDBDSK,SDBHEX,SDBDEC,SDBMAX
;;;	PUBLIC SDBDIR,SDBDAT,SDBTOT
;;;	PUBLIC SHOWHDR
;;;	PUBLIC SHOWALV,SALMSG,SALDSK
;;;	PUBLIC SHOWFIL,SFLMSG,SFLDSK
;;;	PUBLIC SHOWDIR,SDRMSG,SDRDSK
;;;	PUBLIC GOODVERS,USECCP,MAIN,TASK1,TABLE1,RETURN

SEGMENT	CODE

;
; This is the reverse of the DOS protection in the 8080 / Z80 DISKSTAT. It's
; not really relevant in CP/M-86 because the program has a header, but would
; be needed if we were also building a DOS COM file.
;
	DB	0EBh, 04h	; JMPS +04
	DB	0EBh, 0C3h
	DW	CPMHANDLER	; Send x80 processors to CPMHANDLER
	JMP	SHORT	ENTRY

	DB	CR,'MML DISKSTAT 1.2 (8086)',CR,LF
	DB	'Date: 2015-05-09',CR,LF
	DB	1Ah

CPMHANDLER:
        DB      11h             ;LD DE, VERMSG
        DW      VERMSG
        DB      0Eh, 09h        ;LD E,9
        DB      0CDh, 5, 0      ;CALL 5
        DB      0C7h            ;RST 0

;
; Terminal customisation area
;
DOT	DB	'.'		; Empty space
BLOCK	DB	'#'		; Directory block
SOLID	DB	'+'		; Data block
HOLLOW	DB	'-'		; Erased block
CLS	DB	'$',0,0,0,0,0,0,0 ; Clear screen string

IBMCHARS:
        DB      250     ; U+00B7 middle dot
        DB      254     ; U+25A0 black square
        DB      '+'     ; U+2022 bullet
        DB      '-'     ; U+25E6 white bullet
IBM$CLS:
        DB      ESC, 'E', ESC, 'H', '$'

;
ENTRY:	

;------------------------------------------------------------------------
;;;	PAGE

;		===============
;		DISC DATA AREAS
;		===============

;--------------------------------------------------------------
;
; CP/M disc parameters
;
;--------------------------------------------------------------

SEGMENT	DATA
DEF$DSK DB	0		; Selected disc

DPB:				; Drive disk parameter block
DPB$SPT DW	0
DPB$BSH DB	0
DPB$BLM DB	0
DPB$EXM DB	0
DPB$DSM DW	0
DPB$DRM DW	0
DPB$AL0 DB	0
DPB$AL1 DB	0
DPB$CKS DW	0
DPB$OFF DW	0
LEN$DPB2 EQU	$-DPB		; length of CP/M 2 dpb
DPB$PSH DB	0
DPB$PHM DB	0
LEN$DPB3 EQU	$-DPB		; length of CP/M + dpb

DPH2:				; CP/M 2 disk parameter header
DPH2$XLT:
	DW	0
DPH2$ZRO:
	DW	0,0,0
DPH2$DIR:
	DW	0
DPH2$DPB:
	DW	0
DPH2$CSV:
	DW	0
DPH2$ALV:
	DW	0
LEN$DPH2 EQU	$-DPH2		; length of CP/M 2 dph

DPH3:				; CP/M + disk parameter header
DPH3$XLT:
	DW	0
DPH3$ZRO:
	DB	0,0,0,0,0,0,0,0,0
DPH3$MF	DB	0
DPH3$DPB:
	DW	0
DPH3$CSV:
	DW	0
DPH3$ALV:
	DW	0
DPH3$DIR:
	DW	0
DPH3$DAT:
	DW	0
DPH3$HSH:
	DW	0
DPH3$BNK:
	DB	0
	DW	0,0,0
LEN$DPH3 EQU	$-DPH3		; length of CP/M + dph

DPB$PTR DW	0		; address of dpb (offset)
DPB$SEG	DW	0		; address of dpb (segment)
DPH$PTR DW	0		; address of dph

VERS:				; O.S. Version number
VERS$REL:
	DB	0		; O.S. Version/Release number
VERS$OS:DB	0		; O.S. number

POSN	DW	0		; pointer to text string

DOSMEDIA:
	DB	0		; DOS media?

; ------;
; stack ;
; ------;
	DW	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	DW	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
				; dont know how much stack BIOS requires
SAVESP	DW	0
SAVESS	DW	0

; ----------------;
; address equates ;
; ----------------;

DEFFCB	EQU	5CH		; CCP puts default FCB here
DEFDMA	EQU	80H		; CCP sets default DMA here

; -----------------;
; constant equates ;
; -----------------;

BS	EQU	08H		; <BACK SPACE>
CR	EQU	0DH		; <RETURN>
LF	EQU	0AH		; <LINE FEED>
ESC	EQU	1BH		; <ESCAPE>
JUMP	EQU	0C3H		; JP instruction

SEGMENT	CODE

;-------------------------------------------------------------------------;
;;;	PAGE


;-------;
; start ;
;-------;

;
; See if there's an IBM-compatible BIOS present (which we detect by looking
; for its warm boot flag at 40:72)
;
        MOV     AX, 40h
        MOV     ES, AX
        MOV     AX, [ES:72h]    ;Warm boot flag
        MOV     DX, DS
        MOV     ES, DX
        CMP     AX, 1234h
        JNZ     NOT_IBM
;
; Switch to IBM character set
;
        MOV     SI, IBMCHARS
        MOV     DI, DOT
	MOV	CX, 9
        CLD
        REP	MOVSB
NOT_IBM:
;
; Copy the allocation table characters to their rightful places.
;
	MOV	AL,[DOT]
	MOV	[DOT1],AL
	MOV	AL,[BLOCK]
	MOV	[BLOCK1],AL
	MOV	AL,[HOLLOW]
	MOV	[HOLLO1],AL
	MOV	AL,[SOLID]
	MOV	[SOLID1],AL

	MOV	DX,CLS	; If there is a clear-screen message,
	MOV	BX,CSNMSG ; copy it over csnmsg
	XCHG	BX,DX
	MOV	AL,[BX]
	XCHG	BX,DX
	CMP	AL,'$'		; If it's blank (first character is $)
	JZ	CCLS1		; then don't.

CPYCLS:	XCHG	BX,DX
	MOV	AL,[BX]
	XCHG	BX,DX
	MOV	[BX],AL
	CMP	AL,'$'
	JZ	CCLS1
	INC	BX
	INC	DX
	JMP	CPYCLS
CCLS1:
;
; End of 1.2 initialisation code
;
	MOV	CL,12		; BDOS: RETURN VERSION NUMBER
	INT	0E0h
	MOV	AX, BX
	AND	AX, 0FDFFh	; Clear the CP/Net bit
	MOV	[VERS],AX	
	CMP	AX, 0022h	; CP/M-86 v1.x
	JZ	j_GOODVERS
	CMP	AX, 1431h	; CCP/M-86 3.1
	JZ	j_GOODVERS
	CMP	AX, 1441h	; CCP/M-86 4.1
	JZ	j_GOODVERS
	CMP	AX, 1031h	; CP/M-86 Plus
	JZ	j_GOODVERS
	CMP	AX, 1033h	; Apricot PCP/M-86
	JZ	j_GOODVERS
	CMP	AX, 1041h	; DOS Plus 1.x
	JZ	j_GOODVERS
	CMP	AX, 1050h	; DOS Plus 2.x
	JNZ	BADVERS
;
j_GOODVERS:
        JMP     GOODVERS

;
;;;	PAGE
				; ================= ;
				; various utilities ;
				; ================= ;

; -------------- ;
; Error routines ;
; -------------- ;

BADSEL:
	MOV	DX,SELMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	MOV	CL,0		; BDOS: SYSTEM RESET
	MOV	DX,0
	INT	0E0h		; and crash out

SEGMENT	DATA
SELMSG	DB	'FATAL ERROR - Unable to select drive','$'
SEGMENT	CODE

BADVERS:
	MOV	DX,VERMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h		; & RETURN
	RET

SEGMENT	DATA
VERMSG	DB	'Must use CP/M-86 1.x, CP/M-86 Plus, PCP/M-86 or DOS Plus','$'
SEGMENT	CODE
;
; --------------------------- ;
; Direct calls to CP/M 2 BIOS ;
; --------------------------- ;

BIOS:
BADBIOS:			; (NOTE DE may be on stack)
	MOV	DX,JMPMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	MOV	CL,0		; BDOS: SYSTEM RESET
	MOV	DX,0
	INT	0E0h		; and crash out

SEGMENT	DATA
JMPMSG	DB	'FATAL ERROR - Unable to find BIOS','$'
SEGMENT	CODE


; --------------------------- ;
; Direct calls to CP/M 3 BIOS ;
; --------------------------- ;

SEGMENT	DATA
BIOSPB:
BIOS$FUNC:
	DB	0		; BIOS function number (WARM BOOT = 1)
BIOS$CXREG:
	DW	0		; BC register contents
BIOS$DXREG:
	DW	0		; DE register contents
SEGMENT	CODE


;;;	PAGE

; ------------------------------ ;
; Conversion into HEX characters ;
; ------------------------------ ;

;-----------------------------------------------------------------------;
; HEXBYT								;
; Input:	<B> = Count of bytes to be converted			;
;		<HL> -> first byte to be translated			;
;		POSN = pointer to text field				;
; Destroys:	All registers						;
; Function:	Converts <B> bytes starting at <HL> into 2 digit	;
;		hexadecimal characters which are added to next		;
;		hexadecimal field in the text string. POSN is updated	;
;		to point to the end of this hexadecimal field.		;
;-----------------------------------------------------------------------;

;-----;
HEXBYT:
;-----;
	PUSH	BX
	PUSH	CX
	MOV	AL,[BX]
	CALL	BYTHEX
	POP	CX
	POP	BX
	INC	BX
	DEC	CH
	JNZ	HEXBYT
	RET

;-----------------------------------------------------------------------;
; HEXTBL								;
; Input:	<B> = Count of bytes to be converted			;
;		<HL> -> start of array of <B> byte to be translated	;
;		<DE> -> start of table of conversion formats		;
;			1 = single byte					;
;			2 = pair of bytes to be combined as one word	;
;			3 = pair of bytes to reversed in text fields	;
;		POSN = pointer to text field				;
; Destroys:	All registers						;
; Function:	Converts <B> bytes starting at <HL> according to	;
;		format type in table pointed at by <DE>. Each entry	;
;		in the table <DE> corresponds to field positions.	;
;-----------------------------------------------------------------------;

;-----;
HEXTBL:
;-----;
	XCHG	BX,DX
	MOV	AL,[BX]
	XCHG	BX,DX
	PUSH	DX
	CMP	AL,2
	JZ	HEXTBL2
	CMP	AL,3
	JZ	HEXTBL3

; byte
	MOV	AL,[BX]
	PUSH	CX
	PUSH	BX
	CALL	BYTHEX
	JMP	NXTTBL

; word
HEXTBL2:
	DEC	CH		; decrement <B> as using two bytes
	PUSH	CX
	MOV	DL,[BX]
	INC	BX
	MOV	DH,[BX]
	PUSH	BX
	XCHG	BX,DX
	CALL	WRDHEX		; <HL> -> text
	JMP	NXTTBL

; double byte
HEXTBL3:
	DEC	CH		; decrement <B> as using two bytes
	PUSH	CX
	INC	BX
	MOV	AL,[BX]		; display 2nd byte first
	DEC	BX
	PUSH	BX
	CALL	BYTHEX
	POP	BX
	MOV	AL,[BX]		; display 1st byte next
	INC	BX
	PUSH	BX
	CALL	BYTHEX

NXTTBL:	POP	BX
	POP	CX
	POP	DX
	INC	DX
	INC	BX
	DEC	CH
	JNZ	HEXTBL
	RET

;-----------------------------------------------------------------------;
; WRDHEX								;
; Input:	<HL>  = word to converted into hexadecimal text		;
;		POSN = pointer to text field				;
; Destroys:	All registers						;
; Function:	Converts word in <HL> into four hexadecimal characters	;
;		which are added to next hexadecimal field in the	;
;		text string. POSN is updated to point to the end	;
;		of this hexadecimal field.				;
;-----------------------------------------------------------------------;

;-----;
WRDHEX:				; display hex word in <HL> into text
;-----;

	PUSH	BX		; must preserve HL
	CALL	NEXTHEX		; returns DE -> 'h'
	DEC	DX
	DEC	DX
	DEC	DX
	DEC	DX
	POP	BX
	PUSH	BX
	MOV	AL,BH
	CALL	OUTNBL
	POP	BX
	MOV	AL,BL
	CALL	OUTNBL
	RET

;-----------------------------------------------------------------------;
; DBLHEX								;
; Input:	<HL>  = word to converted into hexadecimal text		;
;		POSN = pointer to text field				;
; Destroys:	All registers						;
; Function:	Converts word in <HL> into two pairs of hexadecimal	;
;		characters with the high byte displayed first. Each is	;
;		added to the next hexadecimal field in the text string.	;
;		POSN is updated to point to the end of the second	;
;		is hexadecimal field.					;
;-----------------------------------------------------------------------;

;-----;
DBLHEX:				; display high hex byte into text
;-----;
	MOV	AL,BH
	PUSH	BX
	CALL	BYTHEX
	POP	BX
				; display high hex byte into text
	MOV	AL,BL
	JMP	BYTHEX

;-----------------------------------------------------------------------;
; BYTHEX								;
; Input:	<A>  = byte to converted into hexadecimal text		;
;		POSN = pointer to text field				;
; Destroys:	All registers						;
; Function:	Converts byte in <A> into two hexadecimal characters	;
;		which are added to next hexadecimal field in the	;
;		text string. POSN is updated to point to the end	;
;		of this hexadecimal field.				;
;-----------------------------------------------------------------------;

;-----;
BYTHEX:				; converts byte in <A> into hexadecimal text
;-----;
	LAHF
	PUSH	AX
	CALL	NEXTHEX		; returns DE -> 'h'
	DEC	DX
	DEC	DX
	POP	AX
	SAHF
	CALL	OUTNBL
	RET

;-----;
OUTNBL:				; convert byte in <A> into two hex chars at <DE>
;-----;
	LAHF
	PUSH	AX
	ROR	AL,1
	ROR	AL,1
	ROR	AL,1
	ROR	AL,1
	CALL	NBLHEX
	POP	AX
	SAHF
;-----;
NBLHEX:				; convert nibble in A into hex char in (DE)
;-----;
	AND	AL,0FH
	MOV	CL,AL
	MOV	CH,0
	MOV	BX,HEXTXT
	ADD	BX,CX
	MOV	AL,[BX]
	XCHG	BX,DX
	MOV	[BX],AL
	XCHG	BX,DX
	INC	DX
	RET

;-----------------------------------------------------------------------;
; NEXTHEX								;
; Input:	POSN = pointer to text field				;
; Returns:	<DE> -> to end of hexadecimal filed			;
; Destroys:	<A>, <BC>, <HL> 					;
; Function:	Starting at location (POSN), scans text for hexadecimal ;
;		field of the form ??h or ????h where ? is any valid	;
;		hexadecimal character (0123456789ABCDEF). POSN is	;
;		updated to point to the end of this hexadecimal field.	;
;-----------------------------------------------------------------------;


TESTHEX:
	CMP	AL,CR		; check if end of line, as must not pass this
	JNZ	NEXTHEX
	RET			; even if this means overwriting text.

;------;
NEXTHEX:			; find next hex location in text
;------;

	CALL	HEXCHR		; find first hex character
	JNZ	TESTHEX
	CALL	HEXCHR		; find second hex character
	JNZ	TESTHEX
	INC	DX
	XCHG	BX,DX
	MOV	AL,[BX]
	XCHG	BX,DX
	CMP	AL,'h'
	JNZ	TESTHEX
	RET

HEXCHR:	MOV	BX,[POSN]
	INC	BX
	MOV	AL,[BX]
	MOV	DX,BX
	CMP	AL,CR		; test for end of line
	JNZ	NXT0
	RET

NXT0:	MOV	[POSN],BX		; update POSN
	MOV	BX,HEXTXT
	MOV	CH,16
NXT1:	CMP	AL,[BX]
	JNZ	NXT1A
	RET

NXT1A:	INC	BX
	DEC	CH
	JNZ	NXT1
	OR	AL,-1
	RET

SEGMENT	DATA
HEXTXT	DB	'0123456789ABCDEF'
SEGMENT	CODE

;;;	PAGE
				; ================= ;
				; various functions ;
				; ================= ;


; ------------------------------ ;
; Wait for <RETURN> for keyboard ;
; ------------------------------ ;

WAITCR:
	MOV	DX,CRMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	MOV	CL,10		; DIRECT CONSOLE BUFFER
	MOV	DX,WAITBUFF
	INT	0E0h
	MOV	AL,[WAITLEN]
	OR	AL,AL
	JNZ	WAITCR
	RET

SEGMENT	DATA
CRMSG	DB	CR,LF,'Hit <RETURN> to continue ','$'
WAITBUFF:
	DB	1
WAITLEN:
	DB	0
	DB	0
SEGMENT	CODE


; ---------------------------- ;
; Fetch DPH and DPB for device ;
; ---------------------------- ;

FETCHDP:
	CALL	GETDPB

	MOV	AX,[VERS$REL]
	CMP	AH,14H
	JZ	c_GETDPHC	;CCP/M
	CMP	AX,22h	
	JZ	c_GETDPH2	;CP/M-86 1.x
	
	CALL	GETDPH3
	RET
;
c_GETDPHC:
	CALL	GETDPHC
	RET
;
c_GETDPH2:
	CALL	GETDPH2
	RET

; ---------------- ;
; Fetch CP/M 2 DPH ;
; ---------------- ;

GETDPH2:

	MOV	AL,[DEF$DSK]	; Current selected disk
	MOV	[BIOS$CXREG],AL
	MOV	BX,-1		; Not first time login
	MOV	[BIOS$DXREG],BX
	MOV	AL,9		; BIOS: select the sepcified disk drive
	MOV	[BIOS$FUNC],AL	; save in BIOSPB
	MOV	CL,50		; BDOS: DIRECT BIOS CALL
	MOV	DX,BIOSPB 	; BIOS parameter block
	INT	0E0h	

	AND	BX,BX
	JNZ	GOTDPH2
	JMP	BADSEL	
;
; BX = DPH offset. Find the CP/M data segment.
;
GOTDPH2:
	PUSH	BX
	MOV	CL,1Fh		; DRV_DPB
	INT	0E0h		; Returns DPB address in ES:BX, so ES 
	POP	BX		; is CP/M data segment

	MOV	[DPH$PTR],BX	; save address of DPH
	PUSH	DS
	MOV	AX,ES
	MOV	DS,AX
	MOV	SI,BX		; DS:SI -> source
	MOV	AX,CS
	MOV	ES,AX	
	MOV	DI,DPH2		; ES:DI -> destination
	MOV	CX,LEN$DPH2 / 2
	CLD	
	REP	MOVSW
	POP	DS
	RET

; ------------------------ ;
; Fetch CCP/M / PCP/M  DPH ;
; ------------------------ ;

;
; In CCP/M-86, the DRVTBL is at 0C18h in the CP/M data segment.
;
GETDPHC:
	MOV	CL,1Fh		; DRV_DPB
	INT	0E0h
	MOV	BX, 0C18h	; ES:BX -> DRVTBL
	JMP	GETDPH3C
;
; In CP/M-86 Plus and derivatives, it's at 0F08h in the CP/M data segment.
;
GETDPH3:
	MOV	CL,1Fh		; DRV_DPB
	INT	0E0h
	MOV	BX, 0F08h	; ES:BX -> DRVTBL
GETDPH3C:	
	MOV	AL,[DEF$DSK]	; Current selected disk
	XOR	AH,AH
	ADD	AX,AX		; Offset to selected DRVTBL entry
	ADD	BX,AX
	MOV	SI,[ES:BX]	; ES:SI -> selected DPH
	AND	SI,SI
	JNZ	GOTDPH3
	JMP	BADSEL

GOTDPH3:
	PUSH	DS
	MOV	AX,ES
	MOV	DS,AX		; DS:SI -> source
	MOV	AX,CS
	MOV	ES,AX	
	MOV	DI,DPH3		; ES:DI -> destination
	MOV	CX,LEN$DPH3
	CLD
	REP	MOVSB
	POP	DS
	RET

; --------- ;
; Fetch DPB ;
; --------- ;

GETDPB:

	MOV	CL,31		; BDOS: GET ADDR (DPB PARMS)
	INT	0E0h

	MOV	[DPB$PTR],BX	; save address of DPB
	MOV	AX,ES
	MOV	[DPB$SEG],AX	; and segment

	PUSH	DS
	MOV	DS,AX
	MOV	SI,BX		; DS:SI -> source DPB
	MOV	AX,CS
	MOV	ES,AX
	MOV	DI,DPB		; ES:DI -> destination
	MOV	CX,LEN$DPB3 ; copy maximum length regardless
	CLD
	REP	MOVSB
	POP	DS
	RET

;--------;
CLEARSCRN:
				; clear screen
;--------;
	MOV	DX,CSNMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h		; & RETURN
	RET

SEGMENT	DATA
CSNMSG	DB	CR,LF,LF,LF,LF,LF,LF,LF,LF,LF,LF
	DB	CR,LF,LF,LF,LF,LF,LF,LF,LF,LF,LF
	DB	CR,LF,LF,LF,LF,LF,'$' ; 25 line feeds
SEGMENT	CODE

;------;
SCREEN1:			; display menu
;------;
	MOV	AL,[DEF$DSK]
	ADD	AL,'A'
	MOV	[S1DSK],AL
	MOV	DX,S1MSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0H		; & RETURN
	RET

SEGMENT	DATA
S1MSG	DB	CR,'MML:DISKSTAT         DRIVE '
S1DSK	DB	'A: CHARACTERISTICS '
	DB	CR,LF,LF,LF,LF,LF,LF,LF,LF,LF,LF ; 10 line feeds
	DB	CR,LF,'                   1    Display DPB statistics '
	DB	CR,LF,'                   2    Display DPH statistics '
	DB	CR,LF,'                   3    Display disk ALLOCATION '
	DB	CR,LF		; Later,'                   4    Display file ALLOCATION '
	DB	CR,LF		; Later,'                   5    Display directory ALLOCATION '
	DB	CR,LF,'                   9    Select new disk '
	DB	CR,LF,LF,LF,LF,'$' ; 5 line feeds
SEGMENT	CODE

;-----;
OPTION:				; request option
;-----;

	MOV	DX,OPTMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	MOV	DX,OPTBUF
	MOV	CL,10		; BDOS: READ CONSOLE BUFFER
	INT	0E0h

	MOV	AL,[OPTLEN]
	CMP	AL,0
	JZ	OPTQUIT
	CMP	AL,1
	JNZ	OPTION

	MOV	AL,[OPTCHR]
	CMP	AL,'1'
	JC	OPTION
	CMP	AL,'9'+1
	JNC	OPTION		; value in range 1 to 9
	SUB	AL,'0'

	RET

OPTQUIT:
	OR	AL,-1
	RET

SEGMENT	DATA
OPTMSG	DB	CR,'     Enter your choice, or <RETURN>   ',BS,BS,'$'
OPTBUF	DB	2		; maximum length of buffer
OPTLEN	DB	0		; number of characters returned
OPTCHR	DW	0		; space for up to 2 characters
SEGMENT	CODE


;------;
MAKEHEX:			; module in showblk
;------;


;	'   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 '
;sdbbyt	'  00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h'
;	'     SPT  BSH BLM EXM    DSM     DRM  AL0-AL1    CKS     OFF  PSH PHM'
;sdbhex	'    0000h 00h 00h 00h   0000h   0000h 00h 00h   0000h   0000h 00h 00h'

	MOV	BX,SDBBYT
	MOV	[POSN],BX

	MOV	AX,[VERS$REL]
	CMP	AX,22h
	JNZ	MAKEH3

	XOR	AL,AL		; CP/M 2  does not have PSH & PHM
	MOV	[DPB$PSH],AL	; - set to zero
	MOV	[DPB$PHM],AL

MAKEH3:

	MOV	BX,DPB
	MOV	CH,17
	CALL	HEXBYT

	MOV	BX,SDBHEX
	MOV	[POSN],BX

	MOV	BX,DPB
	MOV	CH,17
	MOV	DX,HBTYPE
	CALL	HEXTBL

	RET

SEGMENT	DATA
HBTYPE	DB	2,1,1,1,2,2,1,1,2,2,1,1
SEGMENT	CODE


;------;
MAKEDEC:			; module in showblk
;------;

	MOV	BX,SDBDEC
	MOV	[POSN],BX

	MOV	BX,[DPB$SPT]
	CALL	WRDDEC		; <HL> -> text

	MOV	AL,[DPB$BSH]
	CALL	BYTDEC		; <A> -> text
	MOV	AL,[DPB$BLM]
	CALL	BYTDEC		; <A> -> text

	MOV	AL,[DPB$EXM]
	CALL	BYTDEC		; <A> -> text

	MOV	BX,[DPB$DSM]
	CALL	WRDDEC		; <HL> -> text

	MOV	BX,[DPB$DRM]
	CALL	WRDDEC		; <HL> -> text

	MOV	AL,[DPB$AL0]
	CALL	BYTDEC		; <A> -> text
	MOV	AL,[DPB$AL1]
	CALL	BYTDEC		; <A> -> text

	MOV	BX,[DPB$CKS]
	CALL	WRDDEC		; <HL> -> text

	MOV	BX,[DPB$OFF]
	CALL	WRDDEC		; <HL> -> text

	MOV	AX,[VERS$REL]
	CMP	AX,22h
	JZ	DEC2

	MOV	AL,[DPB$PSH]
	CALL	BYTDEC		; <A> -> text
	MOV	AL,[DPB$PHM]
	CALL	BYTDEC		; <A> -> text

	RET

DEC2:	XOR	AL,AL
	CALL	BYTDEC		; <A> -> text
	XOR	AL,AL
	CALL	BYTDEC		; <A> -> text
	RET

ERRDEC:				; fill display with 3 asterisks as error
	CALL	NEXTDEC		; <DE> -> leftmost digit
	MOV	AX,DS
	MOV	ES,AX
	MOV	DI,[POSN]	; [1.1]
	MOV	AL,'*'		; set 1st 3 digits to '*'
	STD
	STOSB
	STOSB
	STOSB
	CLD
	RET


BYTDEC:				; display byte in A as decimal characters
	MOV	BH,0
	MOV	BL,AL

WRDDEC:				; display word in HL as decimal characters
	MOV	CX,0
	JMP	TXTDEC

MEGDEC:				; display byte,word in C & HL as decimal characters
	MOV	CH,0

GIGDEC:				; display double word in BC & HL as decimal characters


TXTDEC:
	XCHG	BX,DX
	PUSH	DX		; save 4 bytes of binary number
	PUSH	CX
	CALL	NEXTDEC		; <DE> -> leftmost digit
	POP	CX
	POP	DX
	CALL	TOBCD		; converts <B>, <C>, <D>, <E> into bcd at BCD
	MOV	BX,[POSN]
	XCHG	BX,DX		; recover <DE> -> leftmost digit
	MOV	AL,'0'		; initialise 1st digit to a zero
	XCHG	BX,DX
	MOV	[BX],AL
	XCHG	BX,DX		; (just to make sure )

	MOV	BX,BCDLSB ; start with least significent digit
TXTDEC1:
	CALL	TXTBCD
	JNZ	TXTDEC2
	RET
TXTDEC2:
	DEC	BX
	JMP	TXTDEC1		; continue till all 10 digits done

TXTBCD:				; HL -> bcd digit, <DE> -> txt postion
	CALL	ZROBCD		; zero when no more BCD digits (destroys <A>, <BC>)
	JNZ	TXTBCD2
	RET
TXTBCD2:
	MOV	AL,[BX]
	ADD	AL,'0'
	XCHG	BX,DX
	MOV	[BX],AL
	XCHG	BX,DX
	DEC	DX
	XOR	AL,AL
	MOV	[BX],AL		; zero BCD byte ESSENTIAL to exit when done
	OR	AL,-1
	RET

ZROBCD:				; test for all bytes of BCD being zero
				; this is important as eventually all bytes
				; will be set to zero during transfer to text
	PUSH	BX
	MOV	BX,BCD
	XOR	AL,AL
	MOV	CH,10
NXTZRO:	OR	AL,[BX]
	JNZ	NXTZ1
	INC	BX
	DEC	CH
	JNZ	NXTZRO
;	# DJNZ NXTZRO
NXTZ1:	POP	BX
	RET

;----;
TOBCD:				; print binary number 0-65535 from <HL>
;----;
	MOV	BX,BINARY
	MOV	[BX],DX		; least significant digit
	INC	BX
	INC	BX
	MOV	[BX],CX		; most significent digit
	MOV	DI,BCD
	MOV	AX,DS
	MOV	ES,AX
	PUSH	CX
	MOV	CX,10
	XOR	AL,AL		; first zero all digits
	CLD
	REP	STOSB
	POP	CX

	MOV	AL,CH
	OR	AL,AL
	JNZ	UPGIG

	OR	AL,CL
	JNZ	UPMEG

	OR	AL,DH
	JNZ	UPWRD

	OR	AL,DL
	JNZ	UPBYT
	RET			; number is zero so return

UPBYT:	MOV	CX,BCDBYT ; start of BCD pointer
	MOV	SI,BYT10
	JMP	UPNXT

UPWRD:	MOV	CX,BCDWRD ; start of BCD pointer
	MOV	SI,WRD10
	JMP	UPNXT

UPMEG:	MOV	CX,BCDMEG ; start of BCD pointer
	MOV	SI,MEG10
	JMP	UPNXT

UPGIG:	MOV	CX,BCDGIG ; start of BCD pointer
	MOV	SI,GIG10
;
UPNXT:	MOV	DI,BINARY ; binary number to be converted
	PUSH	CX		; save BCD pointer
	MOV	CL,-1
PDECL:	INC	CL
	XOR	AL,AL
	MOV	BX,[DI]		; This bit rewritten to use 16-bit arithmetic
	ADD	BX,[SI]		; rather than 8-bit
	MOV	[DI],BX
	MOV	BX,[DI+2]
	ADC	BX,[SI+2]
	MOV	[DI+2],BX
	JC	PDECL		; repeatedly subtract amount till carry set

	MOV	BX,[DI]
	SUB	BX,[SI]
	MOV	[DI],BX
	MOV	BX,[DI+2]
	SBB	BX,[SI+2]
	MOV	[DI+2],BX

	MOV	AL,CL
	POP	BX		; pointer to BCD
	MOV	[BX],AL
	INC	BX
	MOV	CX,BX
	ADD	SI,4		; [1.1] Check both bytes of the word at (HL)
	MOV	AX,[SI]		; not just the low one.
	AND	AX,AX
	JNZ	UPNXT
	RET

SEGMENT	DATA

BCD:				; 10 bytes, 10 digits of BCD text
BCDGIG:				; max number is 4294967295
BCD$0	DB	4
BCD$1	DB	2
BCDMEG:				; max number is 16777215
BCD$2	DB	9
BCD$3	DB	4
BCD$4	DB	9
BCDWRD:				; max number is 65535
BCD$5	DB	6
BCD$6	DB	7
BCDBYT:				; max number is 255
BCD$7	DB	2
BCD$8	DB	9
BCDLSB:
BCD$9	DB	5

GIG10	DW	13824,-15259	; -1000000000 (C465 3600H)
	DW	7936, -1526	;  -100000000 (FA0A 1F00H)
MEG10	DW	27008,  -153	;   -10000000 (FF67 6980H)
	DW	-16960,   -16	;    -1000000 (FFF0 BDC0H)
	DW	31072,    -2	;     -100000 (FFFE 7960H)
WRD10	DW	-10000,    -1	;      -10000 (FFFF D8F0H)
	DW	-1000,    -1	;       -1000 (FFFF FC18H)
BYT10	DW	-100,    -1	;        -100 (FFFF FF9CH)
	DW	-10,    -1	;         -10 (FFFF FFF6H)
	DW	-1,    -1	;          -1 (FFFF FFFFH)
	DW	0,     0	;           0 (0000 0000H) this terminates all

BINARY	DB	0,0,0,0		; binary number filled from E, D, C, & B

SEGMENT	CODE

TESTDEC:
	CMP	AL,CR
	JNZ	NEXTDEC
	RET
NEXTDEC:			; find next dec location in text and convert to space
				; and return DE -> to end of 00h string

	CALL	DECCHR		; find first dec character
	JNZ	TESTDEC
NXT3:	MOV	AL,' '		; erase each digit as we go
	XCHG	BX,DX
	MOV	[BX],AL
	XCHG	BX,DX
	CALL	DECCHR		; scan subsequent dec characters
	JZ	NXT3
	DEC	DX
	MOV	AL,'0'
	XCHG	BX,DX
	MOV	[BX],AL		; initialise 1st digit to a zero
	MOV	[POSN],BX
	XCHG	BX,DX		; [1.1] Bring DE back
	RET

DECCHR:	MOV	BX,[POSN]
	INC	BX
	MOV	AL,[BX]
	MOV	DX,BX
	CMP	AL,CR
	JNZ	NXT4
	RET

NXT4:	MOV	[POSN],BX
	MOV	BX,DECTXT
	MOV	CH,12		; [1.1] Check 12 chars, not 11.
NXT2:	CMP	AL,[BX]
	JNZ	NXT5
	RET
NXT5:	INC	BX
	DEC	CH
	JNZ	NXT2
	OR	AL,-1
	RET
SEGMENT	DATA
DECTXT	DB	'0123456789+*'	; + used for bit flag, * used for errors
SEGMENT	CODE

;------;
MAKEMAX:			; module in showblk
;------;

;'          BLOCK       EXTENT      MAX DISK    DIRECTORY   CHECK SUM   SECTOR'
;'          SIZE (K)    FOLDS       SIZE (K)    ENTRIES     ENTRIES     SIZE'
;'DPB(DEC):  16K          15        1048576      65536       65536      32768'

	MOV	BX,SDBMAX
	MOV	[POSN],BX

	MOV	AL,[DPB$BSH]
	MOV	BX,128
	OR	AL,AL
	JZ	MAKEM2
MAKEM1:	ADD	BX,BX
	DEC	AL
	JNZ	MAKEM1
MAKEM2:	MOV	AL,BH		; /256
	ROR	AL,1		; /512
	ROR	AL,1		; /1024
	LAHF
	PUSH	AX
	MOV	AL,[DPB$BLM]
	MOV	CX,-128
	OR	AL,AL
	JZ	MAKEM4
MAKEM3:	ADD	BX,CX
	DEC	AL
	JNZ	MAKEM3
MAKEM4:	ADD	BX,CX
	POP	AX
	SAHF			; recover K
	MOV	CH,AL		; and save
	MOV	AL,BH
	OR	AL,BL
	MOV	AL,CH
	JZ	MAKE4A
	CALL	ERRDEC
	JMP	MAKE4B

MAKE4A:	CALL	BYTDEC		; <A> -> text

MAKE4B:	MOV	AL,[DPB$BLM]
	ADD	AL,1		; +1
	RCR	AL,1
	RCR	AL,1
	RCR	AL,1		; /8
	MOV	CH,AL		; save EXM+1
	MOV	BX,[DPB$DSM]
	XOR	AL,AL		; (there must be an easier way)
	SUB	AL,BH
	DEC	AL
	CMC
	ADC	AL,BH		; a = 0 if H = 0, else a = -1
	AND	AL,CH
	ADD	AL,CH
	ADD	AL,-1		; -1  (convert into EXM)
	MOV	CH,AL		; and save	

	MOV	AL,[DPB$EXM]
	CMP	AL,CH
	JZ	MAKE4C
	CALL	ERRDEC
	JMP	MAKE4D

MAKE4C:	CALL	BYTDEC		; <A> -> text
MAKE4D:	XOR	AL,AL
	MOV	BX,[DPB$DSM]
	MOV	CX,1
	ADD	BX,CX		; increment dsm by 1
	ADC	AL,0
	MOV	CL,AL		; and save in C
	MOV	AL,[DPB$BSH]
	ADD	AL,-3
	MOV	CH,AL
	OR	AL,AL
	MOV	AL,CL		; giga byte
	JZ	MAKEM6
MAKEM5:	ADD	BX,BX
	ADC	AL,0
	DEC	CH
	JNZ	MAKEM5
MAKEM6:	MOV	CL,AL
	CALL	MEGDEC		; <C> & <HL> -> text

	XOR	AL,AL
	MOV	BX,[DPB$DRM]
	MOV	CX,1
	ADD	BX,CX		; increment drm by 1
	ADC	AL,0
	MOV	CL,AL
	CALL	MEGDEC		; <C> & <HL> -> text

	MOV	BX,[DPB$DRM]
	SHR	BX,1		; /2
	SHR	BX,1		; /4
	MOV	DX,BX
	INC	DX		; DE=HL+1

	MOV	BX,[DPB$CKS]
	MOV	AL,BH
	OR	AL,BL
	JZ	MAKEM8		; no check sum
	MOV	AL,BH
	AND	AL,7FH
	OR	AL,BL
	JZ	MAKEM7		; bit 15 set for non removable
	SUB	BX,DX		; Set the Z based on HL

	XCHG	BX,DX
	JZ	MAKEM8
	CALL	ERRDEC
	JMP	MAKEM9
MAKEM8:	MOV	CL,0
	CALL	MMEGX4		; <C>, <HL> * 4
	CALL	MEGDEC		; <C> & <HL> -> text
	JMP	MAKEM9
MAKEM7:	XOR	AL,AL
	CALL	NEXTDEC
;;;	# LD DE,(POSN)		; [1.1]
	XCHG	BX,DX
	MOV	BX,[POSN]

	DEC	BX
	MOV	BYTE [BX],'+'
	INC	BX
	INC	BX
	XCHG	BX,DX
MAKEM9:

	MOV	AX,[VERS$REL]
	CMP	AX,22h
	JZ	MAKEM0

	MOV	AL,[DPB$PSH]
	MOV	BX,128
	OR	AL,AL
	JZ	MAKE02
MAKE01:	ADD	BX,BX
	DEC	AL
	JNZ	MAKE01
MAKE02:	PUSH	BX
	MOV	AL,[DPB$PHM]
	MOV	CX,-128
	OR	AL,AL
	JZ	MAKE04
MAKE03:	ADD	BX,CX
	DEC	AL
	JNZ	MAKE03
MAKE04:	ADD	BX,CX
	MOV	AL,BH
	OR	AL,BL
	POP	BX
	LAHF
	PUSH	AX
	JZ	MAKE05
	CALL	ERRDEC
MAKE05:	POP	AX
	SAHF
	JNZ	MAKE06
	CALL	WRDDEC		; <HL> -> text
MAKE06: RET

MAKEM0:	MOV	BX,128	; CP/M 2 sector size
	CALL	WRDDEC		; <HL> -> text
	RET


;--------;
MAKEDIR:			; module in showblk
;--------;

;'                             Data       1K    128 byte  '
;'                            Blocks    Blocks   Records    Capacity'
;'              Directory      65535  16777215  16777215    16777215 Entries'
;'              Data           65535  16777215  16777215  4294967296 Bytes'
;'                             65000  16777215  16777215'

SEGMENT	DATA
DIRDB	DB	0		; save number of director blocks
DBSIZE	DB	0		; save data block size in K
SEGMENT	CODE

	MOV	BX,SDBDIR
	MOV	[POSN],BX

	MOV	BX,[DPB$AL0]
	XOR	AL,AL
	MOV	CH,16
MAKED0:	ADD	BX,BX
	ADC	AL,0
;;;	# DJNZ MAKED0		; number of directory data blocks
	DEC	CH
	JNZ	MAKED0
	MOV	[DIRDB],AL

	CALL	BYTDEC		; <A> -> text

	MOV	AL,[DPB$BSH]
	MOV	BX,128
	OR	AL,AL
	JZ	MAKED2
MAKED1:	ADD	BX,BX
	DEC	AL
	JNZ	MAKED1
MAKED2:	MOV	AL,BH		; /256
	ROR	AL,1		; /512
	ROR	AL,1		; /1024
	MOV	[DBSIZE],AL	; save data block size in K

	MOV	CL,AL
	MOV	CH,0
	MOV	AL,[DIRDB]
	MOV	BX,0
	OR	AL,AL
	JZ	MAKED4
MAKED3:	ADD	BX,CX
	DEC	AL
	JNZ	MAKED3
MAKED4:	PUSH	BX
	CALL	WRDDEC		; <HL> -> text
	POP	BX

	MOV	CL,0
	CALL	MMEGX8		; multiply by 8

	PUSH	BX
	PUSH	CX
	CALL	MEGDEC		; number of records (<C> & <HL> -> text)
	POP	CX
	POP	BX

	CALL	MMEGX4		; multiply by 4
	CALL	MEGDEC		; number of entries (<C> & <HL> -> text)
	RET

;--------;
MAKEDAT:			; module in showblk
;--------;

;'                             Data       1K    128 byte  '
;'                            Blocks    Blocks   Records    Capacity'
;'              Directory      65535  16777215  16777215    16777215 Entries'
;'              Data           65535  16777215  16777215  4294967296 Bytes'
;'                             65000  16777215  16777215'

	MOV	BX,SDBDAT
	MOV	[POSN],BX

	MOV	BX,[DPB$DSM]	; total disk blocks
	MOV	AL,[DIRDB]	; blocks reserved for directory
	DEC	AL
	MOV	CL,AL
	MOV	CH,0

;;;	# SBC HL,BC		; leaving number of data blocks
	SBB	BX,CX

	PUSH	BX
	CALL	WRDDEC		; <HL> -> text
	POP	BX

	XOR	AL,AL
	MOV	CH,AL
	MOV	CL,AL		; BC = 0

	MOV	AL,[DPB$BLM]
	INC	AL
	ROR	AL,1
	ROR	AL,1
	ROR	AL,1		; /8
MAKED5:	ROR	AL,1		; [1.1] This loop rewritten ...
	JC	MAKED6
	LAHF
	PUSH	AX
	CALL	MGIGX2
	POP	AX
	SAHF
	JMP	MAKED5		; [1.1] ... to here

MAKED6:	PUSH	CX
	PUSH	BX
	CALL	GIGDEC		; 1K blocks (<BC> & <HL> -> text)
	POP	BX
	POP	CX
	CALL	MGIGX8		; multiply B,C,H,& L by 8

	PUSH	BX
	PUSH	CX
	CALL	GIGDEC		; number of records (<BC> & <HL> -> text)
	POP	CX
	POP	BX

	CALL	MGIGX128	; multiply B,C,H,& L by 128
	CALL	GIGDEC		; number of bytes (<BC> & <HL> -> text)

	RET

;--------;
MAKETOT:			; module in showblk
;--------;

;'                             Data       1K    128 byte  '
;'                            Blocks    Blocks   Records    Capacity'
;'              Directory      65535  16777215  16777215    16777215 Entries'
;'              Data           65535  16777215  16777215  4294967296 Bytes'
;'                             65000  16777215  16777215'

	MOV	BX,SDBTOT
	MOV	[POSN],BX

	XOR	AL,AL
	MOV	CX,1
	MOV	BX,[DPB$DSM]	; total disk blocks
	ADD	BX,CX
	ADC	AL,AL
	MOV	CL,AL

	PUSH	CX
	PUSH	BX
	CALL	WRDDEC		; <HL> -> text
	POP	BX
	POP	CX

	MOV	AL,[DPB$BLM]
	INC	AL
	ROR	AL,1
	ROR	AL,1
	ROR	AL,1		; /8
MAKED7:	ROR	AL,1		; [1.1] Rewritten to match maked5/maked6
	JC	MAKED8
	LAHF
	PUSH	AX
	CALL	MGIGX2
	POP	AX
	SAHF
	JMP	MAKED7
;
MAKED8:	PUSH	CX
	PUSH	BX
	CALL	GIGDEC		; 1K blocks (<BC> & <HL> -> text)
	POP	BX
	POP	CX

	CALL	MGIGX8		; multiply B,C,H,& L by 8
	CALL	GIGDEC		; number of records (<BC> & <HL> -> text)

	RET

MMEGX8:	CALL	MMEGX2		; multiply C,H,& L by 8
MMEGX4:	CALL	MMEGX2		; multiply C,H,& L by 4
MMEGX2:	MOV	AL,BL		; multiply C,H,& L by 2
	ADD	AL,AL
	MOV	BL,AL
	MOV	AL,BH
	ADC	AL,AL
	MOV	BH,AL
	MOV	AL,CL
	ADC	AL,AL
	MOV	CL,AL
	RET

MGIGX8:	CALL	MGIGX2		; multiply B,C,H,& L by 8
MGIGX4:	CALL	MGIGX2		; multiply B,C,H,& L by 4
MGIGX2:	MOV	AL,BL		; multiply B,C,H,& L by 2
	ADD	AL,AL
	MOV	BL,AL
	MOV	AL,BH
	ADC	AL,AL
	MOV	BH,AL
	MOV	AL,CL
	ADC	AL,AL
	MOV	CL,AL
	MOV	AL,CH
	ADC	AL,AL
	MOV	CH,AL
	RET

MGIGX128:
				; multipy B,C,H,& L by 128
	MOV	AL,CH
	AND	AL,AL
	RCR	AL,1		; we can only use lowest bit
	MOV	AL,CL
	RCR	AL,1
	MOV	CH,AL
	MOV	AL,BH
	RCR	AL,1
	MOV	CL,AL
	MOV	AL,BL
	RCR	AL,1
	MOV	BH,AL
	MOV	AL,0
	RCR	AL,1
	MOV	BL,AL
	RET



;------;
SHOWBLK:			; menu 1 option 1    Display DPB statistics
;------;
	MOV	AL,[DEF$DSK]
	ADD	AL,'A'
	MOV	[SDBDSK],AL

	CALL	MAKEHEX

	CALL	MAKEDEC

	CALL	MAKEMAX

	CALL	MAKEDIR

	CALL	MAKEDAT

	CALL	MAKETOT


	MOV	DX,SDBMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	CALL	WAITCR

	RET

SEGMENT	DATA
SDBMSG:
	DB	CR,   '                         DRIVE '
SDBDSK	DB	'A: DISC PARAMETER BLOCK'
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'   0   1   2   3   4   5   6   7   8'
	DB	'   9  10  11  12  13  14  15  16 '
	DB	CR,LF,'DPB:     '
SDBBYT	DB	'  00h 00h 00h 00h 00h 00h 00h 00h 00h'
	DB	' 00h 00h 00h 00h 00h 00h 00h 00h'
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'     SPT  BSH BLM EXM    DSM     DRM  '
	DB	'AL0-AL1    CKS     OFF  PSH PHM'
	DB	CR,LF,'DPB(HEX):'
SDBHEX	DB	'    0000h 00h 00h 00h   0000h   0000h '
	DB	'00h 00h   0000h   0000h 00h 00h'
	DB	CR,LF,'DPB(DEC):'
SDBDEC	DB	'   65535  255 255 255  65535   65535  '
	DB	'255 255  65535   65535  255 255'
	DB	CR,LF
	DB	CR,LF,'          BLOCK       EXTENT    '
	DB	'  MAX DISK    DIRECTORY   CHECK SUM   SECTOR'
	DB	CR,LF,'          '
	DB	'SIZE (K)    FOLDS       SIZE (K)    ENTRIES'
	DB	'     ENTRIES     SIZE'
	DB	CR,LF,'DPB(DEC): '
SDBMAX	DB	' 16K          15        1048576      65536 '
	DB	'      65536      32768'
SDBERR	DB	CR,LF,''
	DB	CR,LF
	DB	CR,LF,'ALLOCATION OF DISK BLOCKS'
	DB	CR,LF,'                             Data       1K    128 byte  '
	DB	CR,LF,'                            Blocks    Blocks   Records  '
	DB	'  Capacity'
	DB	LF
SDBDIR	DB	CR,LF,'              Directory      65535  16777215  16777215  '
	DB	'  16777215 Entries'
SDBDAT	DB	CR,LF,'              Data           65535  16777215  16777215  '
	DB	'4294967296 Bytes'
	DB	CR,LF,'                          --------  --------  --------'
SDBTOT	DB	CR,LF,'                             65000  16777215  16777215'
	DB	LF
	DB	'$'
SEGMENT	CODE

;------;
MAKEDPH3:
				; menu 1 option 2    Display DPH statistics
;------;

;	'   0   1   2   3   4   5   6   7   8   9  10  11  '
;s3byt1	'  00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h '
;	'  12  13  14  15  16  17  18  19  20  21  22  23  24  '
;s3byt2	'  00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h '
;	'  XLT     -0- -0- -0- -0- -0- -0- -0- -0- -0- MF  '
;s3hex1	'  0000h   00h 00h 00h 00h 00h 00h 00h 00h 00h 00h '
;	'  DPB     CSV     ALV     DIRBCB  DTABCB  HASH    HBANK'
;s3hex2	'  0000h   0000h   0000h   0000h   0000h   0000h   00h '

	MOV	BX,S3BYT1
	MOV	[POSN],BX

	MOV	BX,DPH3
	MOV	CH,12
	CALL	HEXBYT

	MOV	SI,S3BYT2
	MOV	[POSN],SI
	MOV	CH,12
	CALL	HEXBYT

	MOV	SI,S3BYT3
	MOV	[POSN],SI
	MOV	CH,7
	CALL	HEXBYT

	MOV	BX,S3HEX1
	MOV	[POSN],BX
	MOV	BX,DPH3
	MOV	DX,H3TYPE
	MOV	CH,12
	CALL	HEXTBL

	MOV	SI,S3HEX2
	MOV	[POSN],SI
	MOV	CH,12
	CALL	HEXTBL

	MOV	SI,S3HEX3
	MOV	[POSN],SI
	MOV	CH,7
	CALL	HEXTBL
	RET


SEGMENT	DATA
H3TYPE	DB      2,1,1,1,1,1,1,2,2       ;Line 1
        DB      2,2,2,2,2,2             ;Line 2
        DB      2,2,1,1,1
SEGMENT	CODE

MAKEDPHM:
        MOV     BX,SMBYT1
        MOV     [POSN], BX
        MOV     BX,DPH3
        MOV     CH,0CH
        CALL    HEXBYT
        MOV     SI,SMBYT2
        MOV     [POSN], SI
        MOV     CH,09H
        CALL    HEXBYT
        MOV     BX,SMHEX1
        MOV     [POSN],BX
        MOV     BX,DPH3
        MOV     DX,HMTYPE
        MOV     CH,0Ch
        CALL    HEXTBL
        MOV     SI,SMHEX2
        MOV     [POSN],SI
        MOV     CH,09h
        CALL    HEXTBL
        RET


;------;
MAKEDPH2:
				; menu 1 option 2    Display DPH statistics
;------;

;	'   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  '
;s2byt	'  00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h '
;	'  XLT     -0- -0- -0- -0- -0- -0- DIRBCB  DPB     CSV     ALV     '
;s2hex	'  0000h   00h 00h 00h 00h 00h 00h 0000h   0000h   0000h   0000h   '

	MOV	BX,S2BYT
	MOV	[POSN],BX

	MOV	BX,DPH2
	MOV	CH,16
	CALL	HEXBYT

	MOV	BX,S2HEX
	MOV	[POSN],BX

	MOV	BX,DPH2
	MOV	DX,H2TYPE
	MOV	CH,16
	CALL	HEXTBL

	RET


SEGMENT	DATA
H2TYPE	DB	2,1,1,1,1,1,1,2,2,2,2 ; 11 fields
SEGMENT	CODE


	RET

;------;
SHOWHDR:			; menu 1 option 2    Display DPH statistics
;------;

	MOV	AX,[VERS$REL]
	CMP	AH,14h		; CCP/M
	JNZ	SHOWHDR1
	CALL	OUTDPHM
SHOWHDR1:
	MOV	AX,[VERS$REL]
	CMP	AX,22h		; CP/M-86 1.x
	JNZ	SHOWHDR2
	CALL	OUTDPH2
SHOWHDR2:
	MOV	AX,[VERS$REL]
	CMP	AH,10H		; CP/M-86 Plus, PCP/M-86, DOS Plus
	JNZ	SHOWHDR3
	CALL	OUTDPH3
SHOWHDR3:
	RET

SEGMENT	DATA
HMTYPE	DB 	2,1,1,1,1,1,1,2,2,2,2,2,2,1
SEGMENT	CODE


;------;
OUTDPH3:			; menu 1 option 2    Display DPH statistics
;------;

	MOV	AL,[DEF$DSK]
	ADD	AL,'A'
	MOV	[SH3DSK],AL

	CALL	MAKEDPH3

	MOV	DX,SH3MSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	CALL	WAITCR

	RET


SEGMENT	DATA
SH3MSG	DB	CR,'                     DRIVE '
SH3DSK	DB	'A: DISK PARAMETER HEADER'
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'   0   1   2   3   4   5   6   7   8   9  10  11  '
	DB	CR,LF,'DPH(HEX):'
S3BYT1	DB	'  00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h '
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'  12  13  14  15  16  17  18  19  20  21  22  23  '
	DB	CR,LF,'DPH(HEX):'
S3BYT2	DB	'  00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h '
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'  24  25  26  27  28  29  30  '
	DB	CR,LF,'DPH(HEX):'
S3BYT3	DB	'  00h 00h 00h 00h 00h 00h 00h '
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'  XLT   -0- -0- -0- -0- -0- -0- DPB   CSV'
	DB	CR,LF,'DPH(HEX):'
S3HEX1	DB	'  0000h 00h 00h 00h 00h 00h 00h 0000h 0000h '
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'  ALV     DIRBCB  DTABCB  FAT     CHECK   LOGIN'
	DB	CR,LF,'DPH(HEX):'
S3HEX2	DB	'  0000h   0000h   0000h   0000h   0000h   0000h '
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'  READ    WRITE  UNIT   CTRL  MFLAGS'
	DB	CR,LF,'DPH(HEX):'
S3HEX3	DB	'  0000h   0000h   00h   00h   00h '
	DB	CR,LF,LF,LF
	DB	'$'

SEGMENT	CODE

;------;
OUTDPH2:			; menu 1 option 2    Display DPH statistics
;------;

	MOV	AL,[DEF$DSK]
	ADD	AL,'A'
	MOV	[SH2DSK],AL

	CALL	MAKEDPH2

	MOV	DX,SH2MSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	CALL	WAITCR

	RET


SEGMENT	DATA
SH2MSG	DB	CR,'                     DRIVE '
SH2DSK	DB	'A: DISK PARAMETER HEADER'
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'   0   1   2   3   4   5   6   7'
	DB	'   8   9  10  11  12  13  14  15  '
	DB	CR,LF,'DPH(HEX):'
S2BYT	DB	'  00h 00h 00h 00h 00h 00h 00h 00h '
	DB	'00h 00h 00h 00h 00h 00h 00h 00h '
	DB	CR,LF
	DB	CR,LF,'         '
	DB	'  XLT     -0- -0- -0- -0- -0- -0- DIRBCB  DPB     CSV     '
	DB	'ALV     '
	DB	CR,LF,'DPH(HEX):'
S2HEX	DB	'  0000h   00h 00h 00h 00h 00h 00h 0000h   0000h   0000h   '
	DB	'0000h   '
	DB	CR,LF,LF,LF,LF,LF,LF,LF
	DB	LF,LF,LF,LF,LF,LF,LF,LF
	DB	'$'

SEGMENT	CODE

;------;
OUTDPHM:			; menu 1 option 2    Display DPH statistics
;------;

	MOV	AL,[DEF$DSK]
	ADD	AL,'A'
	MOV	[SHMDSK],AL

	CALL	MAKEDPHM

	MOV	DX,SHMMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	CALL	WAITCR

	RET

SEGMENT	DATA
SHMMSG	DB	CR,'                     DRIVE '
SHMDSK	DB	'A: DISK PARAMETER HEADER'
	DB	CR,LF
	DB	CR,LF
        DB      '            0   1   2   3   4   5   6   7   8   '
        DB      '9  10  11  ',CR,LF
        DB      'DPH(HEX):'
SMBYT1: DB      '  00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h 00h '
        DB      CR,LF,CR,LF
        DB      '           12  13  14  15  16  17  18  19  20  ',CR,LF
        DB      'DPH(HEX):'
SMBYT2:	DB      '  00h 00h 00h 00h 00h 00h 00h 00h 00h ',CR,LF,CR,LF
        DB      '           XLT     -0- -0- -0- -0- -0- -0- DPB   CSV',CR,LF
        DB      'DPH(HEX):'
SMHEX1:	DB      '  0000h   00h 00h 00h 00h 00h 00h 0000h 0000h '
        DB      CR,LF,CR,LF
        DB      '           ALV     DIRBCB  DTABCB  '
        DB      'HASH    HBANK',CR,LF
        DB      'DPH(HEX):'
SMHEX2:	DB      '  0000h   0000h   0000h   0000h   00h '
        DB      CR,LF,LF,LF,LF,LF,LF,LF,LF,LF
	DB	'$'

SEGMENT	CODE


;;;	PAGE

; -------------------------------------------- ;
; utilities used in allocation vector analysis ;
; -------------------------------------------- ;

SEGMENT	DATA
LENALV	DW	0		; length of allocation vector in bytes
ALVDIR	DW	0		; datablocks allocated to directory
ALVDAT	DW	0		; datablocks allocated to data
ALVZRO	DW	0		; datablocks not allocated
ALVERA	DW	0		; datablocks allocated to erased data
ALVLST	DW	0		; datablocks allocated to overwritten data
ALVBAD	DW	0		; datablocks with duplicated data access
ALVRNG	DW	0		; datablocks outside maximum number
ALVLEN	EQU	$-LENALV
USER	DB	0		; save user number
SEGMENT	CODE

;--;
ALV:				; return <HL> = <HL>/8, & <C> = <HL> mod 7
;--;
	MOV	CL,0
	CALL	ALV1		; /2
	CALL	ALV1		; /4
	CALL	ALV1		; /8
	MOV	AL,CL
	ROL	AL,1
	ROL	AL,1
	ROL	AL,1
	MOV	CL,AL
	RET

ALV1:	MOV	AL,BH
	AND	AL,AL
	RCR	AL,1
	MOV	BH,AL
	MOV	AL,BL
	RCR	AL,1
	MOV	BL,AL		; <HL> = <HL> / 2
	MOV	AL,CL
	RCR	AL,1
	MOV	CL,AL		; C contains lost bits
	RET

TSTBIT:				; tst bit number <C> at offset <HL> from ALLOC
				; return CF=NZ if bit already set

	PUSH	CX
	PUSH	BX
	MOV	BX,BITMAP
	MOV	CH,0
	ADD	BX,CX
	MOV	AL,[BX]		; bit to set
	MOV	CX,ALLOC
	POP	BX
	PUSH	BX
	ADD	BX,CX
	MOV	CH,AL		; save bit to set
	MOV	AL,[BX]
	AND	AL,CH		; test if bit set
	POP	BX
	POP	CX
	RET			; 0 = if not set, > 0 if set

SETBIT:				; set bit number <C> at offset <HL> from ALLOC
				; return CF=NZ if bit already set

	PUSH	CX
	PUSH	BX
	MOV	BX,BITMAP
	MOV	CH,0
	ADD	BX,CX
	MOV	AL,[BX]		; bit to set
	MOV	CX,ALLOC
	POP	BX
	PUSH	BX
	ADD	BX,CX
	MOV	CH,AL		; save bit to set
	MOV	AL,[BX]
	MOV	CL,AL		; save byte before setting bit
	OR	AL,CH
	MOV	[BX],AL		; set bit
	MOV	AL,CL
	AND	AL,CH		; test if bit set
	POP	BX
	POP	CX
	RET			; 0 = if not set, > 0 if set



BITMAP	DB	10000000B	; 0
	DB	01000000B	; 1
	DB	00100000B	; 2
	DB	00010000B	; 3
	DB	00001000B	; 4
	DB	00000100B	; 5
	DB	00000010B	; 6
	DB	00000001B	; 7

UPDAT:
	JNZ	ERRBIT		; bit already set
	PUSH	BX
	MOV	BX,[ALVDAT]
	INC	BX
	MOV	[ALVDAT],BX	; increment count of data
	POP	BX
	RET


ERRBIT:				; flag bit already set
	PUSH	BX
	MOV	BX,[ALVBAD]
	INC	BX
	MOV	[ALVBAD],BX	; increment count of duplicate data
	POP	BX
	RET

UPERA:
	JNZ	LSTBIT		; bit already set
	PUSH	BX
	MOV	BX,[ALVERA]
	INC	BX
	MOV	[ALVERA],BX	; increment count of erased data
	POP	BX
	RET

LSTBIT:
	PUSH	BX
	MOV	BX,[ALVLST]
	INC	BX
	MOV	[ALVLST],BX	; increment count of overwritten data
	POP	BX
	RET

UPRNG:
	PUSH	BX
	MOV	BX,[ALVRNG]
	INC	BX
	MOV	[ALVRNG],BX	; increment count of blocks outside range
	POP	BX
	RET

;
; [1.1] Ability to render the first 256 bytes of the allocation vector
; graphically
;
RENDER$ALV:
	LAHF
	PUSH	AX

	MOV	AL,[DOSMEDIA]
	AND	AL,AL
	JNZ	RENDEREND

	CALL	ALV$LENGTH
	MOV	CH,CL		; B = length of ALV
	MOV	BX,0
;
RENDER$ALV$LOOP:
	PUSH	BX
	CALL	ALV		; Locate the bit
	CALL	TSTBIT		; Read it
	POP	BX
	JZ	ALV$NEXT	; If the bit is zero, don't paint
	XCHG	BX,DX
	MOV	AL,DL
	AND	AL,0C0H
	ROL	AL,1
	ROL	AL,1
	ROL	AL,1		; A = row number, 0-3	
	MOV	BX,ALV$TXT
	ADD	AL,BL
	MOV	BL,AL
	MOV	AL,0
	ADC	AL,BH
	MOV	BH,AL		; ADD HL,A
	MOV	AL,[BX]
	INC	BX
	MOV	BH,[BX]
	MOV	BL,AL		; LD HL,(HL)
	MOV	AL,DL
	AND	AL,3FH		; A = column number, 0-63
	ADD	AL,BL
	MOV	BL,AL
	MOV	AL,0
	ADC	AL,BH
	MOV	BH,AL
	MOV	AL,[DOT]	; If there isn't a dot there, it must have
	CMP	AL,[BX]		; been populated by a previous pass
	XCHG	BX,DX
	JNZ	ALV$NEXT
	POP	AX
	SAHF
	XCHG	BX,DX
	MOV	[BX],AL
	XCHG	BX,DX		; Write the character requested
	LAHF
	PUSH	AX
ALV$NEXT:
	INC	BX
	DEC	CH
	JNZ	RENDER$ALV$LOOP

RENDEREND:
	POP	AX
	SAHF
	RET
;
; The four lines of the graphical ALV map
;
ALV$TXT:
	DW	ALV11
	DW	ALV12
	DW	ALV13
	DW	ALV14
;
SEGMENT	CODE
DOSMSG	DB	'   [DOS media -- cannot display allocation]   '
DOSLEN	EQU	$-DOSMSG
SEGMENT	DATA
;
; Initialise the graphical display of the allocation vector.
;
BLANK256:
	MOV	BX,ALV11 ; Zap the first line
	CALL	BLANK64
	MOV	BX,ALV12 ; Second line
	CALL	BLANK64
	MOV	BX,ALV13 ; Third line
	CALL	BLANK64
	MOV	BX,ALV14 ; Fourth line
	JMP	BLANK64

ALV$BLANK:
	CALL	BLANK256
	MOV	BX,[DPB$DSM]
	CALL	ALV$LENGTH	; Fill up to the number of blocks
	MOV	DI,ALV11 ; on the disk with '.'
	MOV	AL,[DOT]
	CALL	ALV$FILL
	JNZ	ALVB1
	RET
ALVB1:	MOV	DI,ALV12
	CALL	ALV$FILL
	JNZ	ALVB2
	RET
ALVB2:	MOV	DI,ALV13
	CALL	ALV$FILL
	JNZ	ALVB3
	RET
ALVB3:	MOV	DI,ALV14
	CALL	ALV$FILL
	RET
;
; Blank one row of the ALV display buffer: 64 characters at HL.
;
BLANK64:
	MOV	CH,64		; Write 64 blanks at HL.
BLANK64A:
	MOV	BYTE [BX],' '
	INC	BX
;;;	# DJNZ BLANK64A
	DEC	CH
	JNZ	BLANK64A
	RET
;
; Write the lesser of C and 64 copies of A at HL.
;
ALV$FILL:
	MOV	CH,64
	PUSH	AX
	MOV	AX,DS
	MOV	ES,AX
	POP	AX
ALV$FILL1:
	STOSB
	DEC	CL
	JZ	ALV$FILL2
	DEC	CH
	JNZ	ALV$FILL1	
	OR	AL,AL
ALV$FILL2:
	RET
;
; Given HL = (number of blocks on the disk - 1), return C = number of blocks  
; to display (with 0 => 256).
;
ALV$LENGTH:

	MOV	AL,BH
	MOV	CL,0
	OR	AL,AL		; If H is nonzero return C = 0
	JNZ	ALV$LEN1
	MOV	CL,BL		; Otherwise return C = L+1
	INC	CL
ALV$LEN1:
	RET
;
; [End of 1.1 helper functions]
;

;------;
SHOWALV:			; menu 1 option 3    Display disk ALLOCATION
;------;
	MOV	AL,[DEF$DSK]
	ADD	AL,'A'
	MOV	[SALDSK],AL

	MOV	AX,DS
	MOV	ES,AX
	MOV	DI,LENALV ; start of datablock counts
	MOV	CX,8
	XOR	AX,AX
	REP	STOSW

	MOV	BX,[DPB$DSM]	; number of data blocks less 1
	CALL	ALV		; return <HL> = <HL>/8, & <C> = <HL> mod 7

	INC	BX
	MOV	[LENALV],BX	; length of ALV in bytes
	MOV	DX,ALLOC	; start of ALV
	ADD	BX,DX		; end of ALV

	XCHG	BX,DX
	MOV	BX,[6]		; Length of segment
	DEC	BX
	SUB	BX,DX		; <HL> = top of TPA - top of ALLOC

	JNC	ALVOK

	MOV	DX,ALVERR
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	JMP	WAITCR		; wait for <RETURN> then return

SEGMENT	DATA
ALVERR	DB	CR,LF,'TPA too small for allocation vector','$'
SEGMENT	CODE

; ---------------------------- ;
; initialise allocation vector ;
; ---------------------------- ;

ALVOK:	CALL	ALV$BLANK	; [1.1] Initialise ALV map
	MOV	CX,[LENALV]
	MOV	DI,ALLOC
	MOV	AX,DS
	MOV	ES,AX
	XOR	AL,AL
	CLD
	REP	STOSB

	MOV	BX,[DPB$AL0]	; directory ALV0 and ALV1
	MOV	[ALLOC],BX	; and fill alloc bits with these

	MOV	BX,7	; ??? render_alv overwrites HL 
	MOV	AL,[BLOCK]
	CALL	RENDER$ALV	; Fill graphical ALV with directory blocks

; ----------------------- ;
; count directory entries ;
; ----------------------- ;

	MOV	CH,16
	MOV	DX,0
CNTALV:	ADD	BX,BX
	JNC	NOCNT
	INC	DX
NOCNT:	DEC	CH
	JNZ	CNTALV
	XCHG	BX,DX
	MOV	[ALVDIR],BX	; number of directory entries

; -------------- ;
; scan directory ;
; -------------- ;

	XOR	AL,AL
	MOV	[DOSMEDIA],AL
	MOV	AX,DS
	MOV	ES,AX
	MOV	DX,DEFFCB
	MOV	DI,DX
	MOV	CX,0Ch
	MOV	AL,'?'
	REP	STOSB
	MOV	CL,17		; BDOS: SEARCH FOR FIRST
	INT	0E0h

NEXTDIR:
	CMP	AL,-1
	JZ	DOERA
	MOV	BL,AL
	MOV	BH,0
	ADD	BX,BX
	ADD	BX,BX
	ADD	BX,BX
	ADD	BX,BX
	ADD	BX,BX
	MOV	DX,DEFDMA
	ADD	BX,DX
	MOV	AL,[BX]	
	CMP	AL,20h		; [x86] Check for DOS media
	JNZ	NXTDOS
	MOV	AH,[BX+0Fh]	; Label byte 0Fh is 80h on DOS media
	CMP	AH,80h		; 
	JNZ	NXTDOS
	MOV	[DOSMEDIA],AH	
NXTDOS:
	AND	AL,0E0h ; NOT 00011111B ; test for high bits set
	JNZ	NXTDCB

	MOV	DX,16
	ADD	BX,DX
	XCHG	BX,DX		; <DE> -> first data block allocation
	MOV	BX,[DPB$DSM]
	MOV	AL,BH
	OR	AL,AL
	JNZ	WRDALV

; test 16 file data block bytes
	MOV	CH,16		; byte wide data blocks
NXTDB:	PUSH	BX
	XCHG	BX,DX
	MOV	AL,[BX]
	XCHG	BX,DX
	OR	AL,AL
	JZ	NULDB
	CMP	AL,BL		; check range
	JZ	UPDB
	JNC	ERRDB
UPDB:	MOV	BL,AL
	MOV	BH,0
	CALL	ALV		; return <HL> = <HL>/8, <C>=MOD(<HL>,7)
	CALL	SETBIT		; returns CF=NZ if bit already set
	CALL	UPDAT
	JMP	NULDB
ERRDB:	CALL	UPRNG		; data block outside range
NULDB:	POP	BX		; recover DSM
	INC	DX		; increment to next data block allocation
	DEC	CH
	JNZ	NXTDB
;;;	# DJNZ NXTDB
	JMP	NXTDCB

; test 8 file data block words
WRDALV:
	XCHG	BX,DX		; move back to HL
	MOV	CH,8
NXTDW:	PUSH	BX
	MOV	DL,[BX]
	INC	BX
	MOV	DH,[BX]
	MOV	AL,DL
	OR	AL,DH
	JZ	NULDW
	MOV	BX,[DPB$DSM]
	XOR	AL,AL
	SUB	BX,DX

	JC	ERRDW
	XCHG	BX,DX
	CALL	ALV		; return <HL> = <HL>/8, <C>=MOD(<HL>,7)
	CALL	SETBIT		; returns CF=NZ if bit already set
	CALL	UPDAT
	JMP	NULDW
ERRDW:	CALL	UPRNG		; data block outside range
NULDW:	POP	BX		; recover data block pointer
	INC	BX
	INC	BX		; increment to next data block allocation
;;;	# DJNZ NXTDW
	DEC	CH
	JNZ	NXTDW

	JMP	NXTDCB

NXTDCB:
	MOV	DX,DEFFCB
	XOR	AL,AL
	XCHG	BX,DX
	MOV	[BX],AL
	XCHG	BX,DX		; set default drive
	MOV	CL,18		; BDOS: SEARCH FOR NEXT
	INT	0E0h
	JMP	NEXTDIR

; -------------- ;
; scan era files ;
; -------------- ;

ERABYT	EQU	0E5H		; CP/M byte for erased file

DOERA:
	MOV	BX,[DPB$DSM]	; Populate data blocks with '+'
	MOV	AL,[SOLID]
	CALL	RENDER$ALV

	MOV	DL,-1		; to fetch user code
	MOV	CL,32		; BDOS: SET/GET USER CODE
	INT	0E0h
	MOV	[USER],AL	; save user number

	MOV	DL,5		; set user = 5
	MOV	CL,32		; BDOS: SET/GET USER CODE
	INT	0E0h

	MOV	DX,DEFFCB
	MOV	AL,'?'
	XCHG	BX,DX
	MOV	[BX],AL
	XCHG	BX,DX
	MOV	CL,17		; BDOS: SEARCH FOR FIRST
	INT	0E0h


NEXTERA:
	CMP	AL,-1
	JZ	ERASED
	MOV	BL,AL
	MOV	BH,0
	ADD	BX,BX
	ADD	BX,BX
	ADD	BX,BX
	ADD	BX,BX
	ADD	BX,BX
	MOV	DX,DEFDMA
	ADD	BX,DX
	MOV	AL,[BX]
	AND	AL,0E0h ; NOT 00011111B ; test for high bits set
	JZ	NXTERA
	MOV	AL,[BX]
	CMP	AL,ERABYT
	JNZ	NXTERA

	PUSH	BX
	MOV	CH,32
TSTERA:	MOV	AL,[BX]
	CMP	AL,ERABYT
	JNZ	NOTERA
	INC	BX
	DEC	CH
	JNZ	TSTERA
				;;;# DJNZ TSTERA	; (doesnt change flags)
NOTERA:	POP	BX
	JZ	ERASED1		; as all 0e5's must be at end

	MOV	DX,16
	ADD	BX,DX
	XCHG	BX,DX		; <DE> -> first data block allocation
	MOV	BX,[DPB$DSM]
	MOV	AL,BH
	OR	AL,AL
	JNZ	WRDERA

; test 16 erased file data block bytes
	MOV	CH,16
NXTEDB:	PUSH	BX		; save DSM
	XCHG	BX,DX
	MOV	AL,[BX]
	XCHG	BX,DX
	OR	AL,AL
	JZ	NULEDB
	CMP	AL,BL		; check range
	JZ	UPEDB
	JNC	ERREDB
UPEDB:	MOV	BL,AL
	MOV	BH,0
	CALL	ALV		; return <HL> = <HL>/8, <C>=MOD(<HL>,7)
	CALL	SETBIT		; returns CF=NZ if bit already set
	CALL	UPERA
	JMP	NULEDB
ERREDB:	CALL	UPRNG		; data block outside range
NULEDB:	POP	BX		; recover DSM
	INC	DX		; increment to next data block byte
	DEC	CH
	JNZ	NXTEDB
	JMP	NXTERA

; test 8 erased file data block words
WRDERA:
	XCHG	BX,DX		; move back to HL
	MOV	CH,8
NXTEDW:	PUSH	BX
	MOV	DL,[BX]
	INC	BX
	MOV	DH,[BX]
	MOV	AL,DL
	OR	AL,DH
	JZ	NULEDW
	MOV	BX,[DPB$DSM]
	XOR	AL,AL
	SUB	BX,DX

	JC	ERREDW
	XCHG	BX,DX
	CALL	ALV		; return <HL> = <HL>/8, <C>=MOD(<HL>,7)
	CALL	SETBIT		; returns CF=NZ if bit already set
	CALL	UPERA
	JMP	NULEDW
ERREDW:	CALL	UPRNG		; data block outside range
NULEDW:	POP	BX		; recover data block pointer
	INC	BX
	INC	BX		; increment to next data block word
;;;	# DJNZ NXTEDW
	DEC	CH
	JNZ	NXTEDW

NXTERA:
	MOV	DX,DEFFCB
	MOV	AL,0E0h ;ERABYT AND 11100000B ; ignore water mark,
	XCHG	BX,DX
	MOV	[BX],AL
	XCHG	BX,DX		; (only works when user=5)
	MOV	CL,18		; BDOS: SEARCH FOR NEXT
	INT	0E0h
	JMP	NEXTERA

ERASED:				; reached end of file
	MOV	BX,[DPB$DSM]	; Populate erased blocks with '+'
	MOV	AL,[HOLLOW]
	CALL	RENDER$ALV
ERASED1:
	MOV	AL,[USER]	; recover user number
	MOV	DL,AL
	MOV	CL,32		; BDOS: SET/GET USER CODE
	INT	0E0h

; --------------------------- ;
; calculate unused datablocks ;
; --------------------------- ;

	MOV	CX,[LENALV]
	MOV	BX,[DPB$DSM]
	MOV	DX,ALLOC
NXTCNT:	PUSH	CX
	XCHG	BX,DX
	MOV	AL,[BX]
	XCHG	BX,DX
	MOV	CH,8
NEXT8:	ADD	AL,AL
	JNC	NOTALC
	DEC	BX		; reduce count by 1
NOTALC:	DEC	CH
	JNZ	NEXT8
;;;	# DJNZ NEXT8
	INC	DX
	POP	CX
	DEC	CX
	MOV	AL,CH
	OR	AL,CL
	JNZ	NXTCNT

	INC	BX		; as started with dsm, not dsm+1
	MOV	[ALVZRO],BX

; ---------------------- ;
; fill text with results ;
; ---------------------- ;

	MOV	BX,ALV01
	MOV	[POSN],BX
	XOR	AL,AL
	MOV	BX,[DPB$DSM]
	MOV	DX,1
	ADD	BX,DX
	ADC	AL,0
	MOV	CL,0
	CALL	MEGDEC		; write total number of datablocks

	MOV	BX,ALV02
	MOV	[POSN],BX
	MOV	BX,[ALVDIR]	; datablocks allocated to directory
	CALL	WRDDEC

	MOV	BX,ALV03
	MOV	[POSN],BX
	MOV	BX,[ALVDAT]	; datablocks allocated to data
	CALL	WRDDEC

	MOV	BX,ALV04
	MOV	[POSN],BX
	MOV	BX,[ALVERA]	; datablocks allocated to erased data
	CALL	WRDDEC

	MOV	BX,ALV05
	MOV	[POSN],BX
	MOV	BX,[ALVLST]	; datablocks allocated to overwritten data
	CALL	WRDDEC

	MOV	BX,ALV06
	MOV	[POSN],BX
	MOV	BX,[ALVBAD]	; datablocks with duplicated data access
	CALL	WRDDEC

	MOV	BX,ALV07
	MOV	[POSN],BX
	MOV	BX,[ALVZRO]	; datablocks not allocated
	CALL	WRDDEC

	MOV	BX,ALV08
	MOV	[POSN],BX
	MOV	BX,[ALVDIR]
	XOR	AL,AL
	MOV	CL,AL
	XCHG	BX,DX
	MOV	BX,[ALVDAT]
	ADD	BX,DX
	ADC	AL,CL
	XCHG	BX,DX
	MOV	BX,[ALVERA]
	ADD	BX,DX
	ADC	AL,CL
	XCHG	BX,DX
	MOV	BX,[ALVZRO]
	ADD	BX,DX
	ADC	AL,CL
	MOV	CL,AL
	CALL	MEGDEC

	MOV	BX,ALV09
	MOV	[POSN],BX
	MOV	BX,[ALVRNG]	; datablocks with duplicated data access
	CALL	WRDDEC

	MOV	AL,[DOSMEDIA]	; We cannot display allocation on DOS media,
	AND	AL,AL		; because the allocation is held in the FAT
	JZ	ALVX01		; rather than in the directory.

	CALL	BLANK256
	MOV	AX,DS
	MOV	ES,AX
	MOV	DI,ALV12
	MOV	SI,DOSMSG
	MOV	CX,DOSLEN
	CLD
	REP	MOVSB
ALVX01:

; ------------ ;
; display text ;
; ------------ ;

	MOV	DX,SALMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	JMP	WAITCR		; wait for <RETURN> then return

SEGMENT	DATA
SALMSG	DB	CR,'                     DRIVE '
SALDSK	DB	'A: DISK ALLOCATION'
	DB	CR,LF
;
; [1.1] Reformatted into two columns to make room for the graphical
;       allocation map.
;
	DB	CR,LF,'                           DATA BLOCKS '
	DB	CR,LF
	DB	CR,LF,'      TOTAL (DRM+1)             '
ALV01	DB	' 65536 '
	DB	CR,LF
	DB	CR,LF,'      Directory                 '
ALV02	DB	'    16 '
	DB	CR,LF,'      Data                      '
ALV03	DB	' 65535 '
	DB	'      Duplicated data           '
ALV06	DB	' 65535 '
	DB	CR,LF,'      Erased and recoverable    '
ALV04	DB	' 65535 '
	DB	'      Erased and reused         '
ALV05	DB	' 65535 '
	DB	CR,LF,'      Unused                    '
ALV07	DB	' 65535 '
	DB	'      Blocks outside range      '
ALV09	DB	' 65535 '
	DB	CR,LF,'                                '
	DB	' ----- '
	DB	CR,LF, '                                '
ALV08	DB	' 65536 '
	DB	CR,LF,LF
;
; [1.1] Display allocation
;
	DB	'    ---- Display of data block allocation '
	DB	'(first 256 bits only) ----'
	DB	CR,LF,'    '
	DB	'0....5...10...15...20...25...30...35...40...45...50...55...60...'
	DB	CR,LF
	DB	'  0 '
ALV11	DB	'                                '
	DB	'                                '
	DB	CR,LF
	DB	' 64 '
ALV12	DB	'                                '
	DB	'                                '
	DB	CR,LF
	DB	'128 '
ALV13	DB	'                                '
	DB	'                                '
	DB	CR,LF
	DB	'196 '
ALV14	DB	'                                '
	DB	'                                '
	DB	CR,LF
	DB	'256    '
BLOCK1	DB	'# Directory  '
SOLID1	DB	'+ Data block  '
HOLLO1	DB	'- Erased block  '
DOT1	DB	'. Unused          '
	DB	CR,LF,LF,LF
	DB	'$'
SEGMENT	CODE

;------;
SHOWFIL:			; menu 1 option 4    Display file ALLOCATION
;------;
	MOV	AL,[DEF$DSK]
	ADD	AL,'A'
	MOV	[SFLDSK],AL
	MOV	DX,SFLMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h		; & RETURN
	RET

SEGMENT	DATA
SFLMSG	DB	CR,'                     DRIVE '
SFLDSK	DB	'A: FILE ALLOCATION'
	DB	LF
	DB	CR,LF,LF,LF,LF,LF,'$' ; 10 line feeds
SEGMENT	CODE

;------;
SHOWDIR:			; menu 1 option 5    Display directory ALLOCATION 
;------;
	MOV	AL,[DEF$DSK]
	ADD	AL,'A'
	MOV	[SDRDSK],AL
	MOV	DX,SDRMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h		; & RETURN
	RET

SEGMENT	DATA
SDRMSG	DB	CR,'                     DRIVE '
SDRDSK	DB	'A: DIRECTORY ALLOCATION'
	DB	LF
	DB	CR,LF,LF,LF,LF,LF,'$' ; 10 line feeds
SEGMENT	CODE

;;;	PAGE

;-----;
SELECT:				; menu 1 option 9    Select new disk
;-----;

	MOV	AL,[DEF$DSK]
	MOV	[OLDDSK],AL	; save in case of error

	CALL	CLEARSCRN
	MOV	DX,SLDMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

; ---------------------- ;
; Request new drive name ;
; ---------------------- ;

SEL0:
	MOV	DX,LOGMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	MOV	DX,SELBUFF
	MOV	CL,10		; BDOS: DIRECT CONSOLE BUFFER
	INT	0E0h
	MOV	AL,[SELLEN]
	OR	AL,AL
	JNZ	SEL0A
	RET			; nothing selected
SEL0A:	CMP	AL,1
	JZ	SEL1
	CMP	AL,2
	JNZ	SEL0
	MOV	AL,[SELDB2]
	CMP	AL,':'
	JNZ	SEL0
SEL1:	MOV	AL,[SELDB1]
	CMP	AL,'a'
	JC	SEL2
	CMP	AL,'z'+1
	JNC	SEL0
	ADD	AL,'A'-'a'	; convert to lower case
SEL2:	SUB	AL,'A'
	CMP	AL,15+1
	JNC	SEL0		; outside range 0-15

	MOV	[DEF$DSK],AL	; Current selected disk

	MOV	CL,13		; BDOS: RESET DISK SYSTEM
	INT	0E0h

	MOV	AL,[DEF$DSK]
	MOV	DL,AL
	MOV	CL,14		; BDOS: SELECT DISK
	INT	0E0h
	OR	AL,AL
	JNZ	SELERR

	CALL	FETCHDP		; fetch dpb and dph for drive

	RET

SELERR:	MOV	AL,[OLDDSK]	; recover previously selecte disk
	MOV	[DEF$DSK],AL
	MOV	DL,AL
	MOV	CL,14		; BDOS: SELECT DISK
	INT	0E0h
	OR	AL,AL
	JNZ	BADSEL
	CALL	FETCHDP		; fetch dpb and dph for drive

	MOV	DX,OLDMSG
	MOV	CL,9		; BDOS: PRINT STRING
	INT	0E0h

	CALL	WAITCR

	RET

SEGMENT	DATA

SLDMSG:
	DB	CR,'                     SELECT NEW DISK'
	DB	LF
	DB	CR,LF,LF,LF,LF,LF,'$' ; 5 line feeds

OLDDSK	DB	0

LOGMSG	DB	CR,'Enter drive name (A:, B:, etc ) ?    ',BS,BS,BS,'$'
SELBUFF:
	DB	3
SELLEN:
	DB	0
SELDB1	DB	0
SELDB2	DW	0

OLDMSG	DB	CR,LF,'--- Unable to select new disk ---'
	DB	CR,LF,LF,LF,LF,LF,'$' ; 5 line feeds




SEGMENT	CODE

;;;	PAGE

;-------;
GOODVERS:
;-------;

	MOV	AL,[DEFFCB]
	DEC	AL
	CMP	AL,-1
	JNZ	USECCP		; use ccp disk

	MOV	CL,25		; BDOS: RETURN CURRENT DISK
	INT	0E0h

USECCP:	MOV	[DEF$DSK],AL	; Current selected disk

	MOV	CL,13		; BDOS: RESET DISK SYSTEM
	INT	0E0h

	MOV	AL,[DEF$DSK]
	MOV	DL,AL
	MOV	CL,14		; BDOS: SELECT DISK
	INT	0E0h
	OR	AL,AL
	JZ	CANSEL
	JMP	BADSEL

CANSEL:
	MOV	AX, SS
	MOV	[SAVESS],AX
	MOV	[SAVESP],SP
	MOV	AX, DS
	MOV	SS, AX
	MOV	SP,SAVESP

	CALL	FETCHDP		; fetch dpb and dph for drive

	CALL	MAIN		; now display as requested

	MOV	AX,[SAVESS]
	MOV	SS,AX
	MOV	SP,[SAVESP]

	MOV	CL,0		; BDOS: SYSTEM RESET
	MOV	DX,0
	INT	0E0h		; & exit

;---;
MAIN:
;---;

	CALL	CLEARSCRN	; clear screen
	CALL	SCREEN1		; display menu
	CALL	OPTION		; request option
	CMP	AL,-1
	JNZ	MAIN1
	RET

MAIN1:	CALL	TASK1
	JMP	MAIN

;----;
TASK1:
;----;

	MOV	CL,AL
	MOV	CH,0
	DEC	CX
	MOV	BX,TABLE1
	ADD	BX,CX
	ADD	BX,CX
	MOV	AL,[BX]
	INC	BX
	MOV	BH,[BX]
	MOV	BL,AL
	JMP	BX

TABLE1	DW	SHOWBLK		; menu 1 option 1    Display DPB statistics
	DW	SHOWHDR		; menu 1 option 2    Display DPH statistics
	DW	SHOWALV		; menu 1 option 3    Display disk ALLOCATION
	DW	SHOWFIL		; menu 1 option 4    Display file ALLOCATION
	DW	SHOWDIR		; menu 1 option 5    Display directory ALLOCATION 
	DW	RETURN
	DW	RETURN
	DW	RETURN
	DW	SELECT		; menu 1 option 9    Select new disk

RETURN:	RET

SEGMENT	DATA
ALLOC	EQU	$		; allocation vector placed at end of program

;
;
;
;
; Line numbers containing untranslated opcodes:
;
; 00277 00344 00488 00563 00593 00609 00847 00869 00917 00930
; 01014 01099 01138 01149 01215 01276 01863 01895 01941 01954
; 01986 02000 02027 02045 02101 02117 02128 02191 02221 02237
; 02248 02283 02601 02608
;

